static const char *demo_vshader_glsl =
"varying vec4 v_glyph;\n"
"varying vec4 v_fill_color;\n"
"varying vec4 v_stroke_color;\n"
"varying float v_stroke_width;\n"
"varying vec2 v_position;\n"
"varying float v_gradient_index;\n"
"varying vec3 v_gradient_info_x;\n"
"varying vec3 v_gradient_info_y;\n"
"uniform float u_scale;\n"
"uniform vec3 u_gradient_info[GRADIENT_INFO_COUNT_V];\n"
"\n"
"vec4\n"
"glyph_vertex_transcode (vec2 v)\n"
"{\n"
"  ivec2 g = ivec2 (v);\n"
"  ivec2 corner = ivec2 (mod (v, 2.));\n"
"  g /= 2;\n"
"  ivec2 nominal_size = ivec2 (mod (vec2(g), 64.));\n"
"  return vec4 (corner * nominal_size, g * 4);\n"
"}\n"
"\n"
"vec3 decode_color(float f)\n"
"{\n"
"  float F = f;\n"
"  float r =  mod(f, 256.0);\n"
"  F = (F - r)/256.0;\n"
"  float g = mod(F , 256.0);\n"
"  F = (F - g)/256.0;\n"
"  float b = mod ( F, 256.0 );\n"
"  return vec3(r,g,b);\n"
"}\n"
"\n"
"void\n"
"main()\n"
"{\n"
"  gl_Position = uMvpMatrix * vec4 (aPosition.xy, 0.0, 1.0);\n"
"  v_glyph = glyph_vertex_transcode (aTexCoord);\n"
"\n"
"  vec3 opacity = decode_color( aNormal.z );\n"
"  v_gradient_index = opacity[2] - 1.0;\n"
"\n"
"  v_fill_color.rgb = decode_color( aNormal.x )/255.0;\n"
"  v_fill_color.a = opacity[0]/255.0;\n"
"\n"
"  v_stroke_color.rgb = decode_color( aNormal.y )/255.0;\n"
"  v_stroke_color.a = opacity[1]/255.0;\n"
"  v_stroke_width = aPosition.z*u_scale;\n"
"  v_position = aPosition.xy;\n"
"\n"
"  int idx = int(opacity[2]-0.5)*2;\n;"
"  v_gradient_info_x = u_gradient_info[idx];\n"
"  v_gradient_info_y =  u_gradient_info[idx+1];\n"
"}\n"
;
